// Copyright 2022 Carnegie Mellon University. All Rights Reserved.
// Released under a MIT (SEI)-style license, please see LICENSE.md in the project root for license information or contact permission@sei.cmu.edu for full terms.

using System;
using System.Collections.Generic;
using System.Data.Common;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using MediatR;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Diagnostics;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Blueprint.Api.Data;
using Blueprint.Api.Data.Models;

namespace Blueprint.Api.Infrastructure.EventHandlers
{
    public class EntityTransactionInterceptor : DbTransactionInterceptor
    {
        private readonly IServiceProvider _serviceProvider;
        private readonly ILogger<EntityTransactionInterceptor> _logger;

        public EntityTransactionInterceptor(
            IServiceProvider serviceProvider,
            ILogger<EntityTransactionInterceptor> logger)
        {
            _serviceProvider = serviceProvider;
            _logger = logger;
        }

        public override async Task TransactionCommittedAsync(
            DbTransaction transaction,
            TransactionEndEventData eventData,
            CancellationToken cancellationToken = default)
        {
            try
            {
                await PublishEvents(eventData);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error in EventTransactionInterceptor");
            }
            finally
            {
                await base.TransactionCommittedAsync(transaction, eventData, cancellationToken);
            }
        }

        public override async void TransactionCommitted(
            DbTransaction transaction,
            TransactionEndEventData eventData)
        {
            try
            {
                await PublishEvents(eventData);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error in EventTransactionInterceptor");
            }
            finally
            {
                base.TransactionCommitted(transaction, eventData);
            }
        }

        private async Task PublishEvents(TransactionEndEventData eventData)
        {
            var entries = GetEntries(eventData.Context as BlueprintContext);

            using (var scope = _serviceProvider.CreateScope())
            {
                var events = new List<INotification>();
                var mediator = scope.ServiceProvider.GetRequiredService<IMediator>();

                foreach (var entry in entries)
                {
                    var entityType = entry.Entity.GetType();
                    Type eventType = null;

                    string[] modifiedProperties = null;

                    switch (entry.State)
                    {
                        case EntityState.Added:
                            eventType = typeof(EntityCreated<>).MakeGenericType(entityType);

                            // Make sure properties generated by the db are set
                            var generatedProps = entry.Properties
                                .Where(x => x.Metadata.ValueGenerated == Microsoft.EntityFrameworkCore.Metadata.ValueGenerated.OnAdd)
                                .ToList();

                            foreach (var prop in generatedProps)
                            {
                                entityType.GetProperty(prop.Metadata.Name).SetValue(entry.Entity, prop.CurrentValue);
                            }

                            break;
                        case EntityState.Modified:
                            eventType = typeof(EntityUpdated<>).MakeGenericType(entityType);
                            modifiedProperties = entry.Properties
                                .Where(x => x.IsModified)
                                .Select(x => x.Metadata.Name)
                                .ToArray();
                            break;
                        case EntityState.Deleted:
                            eventType = typeof(EntityDeleted<>).MakeGenericType(entityType);
                            break;
                    }

                    if (eventType != null)
                    {
                        INotification evt;

                        if (modifiedProperties != null)
                        {
                            evt = Activator.CreateInstance(eventType, new[] { entry.Entity, modifiedProperties }) as INotification;
                        }
                        else
                        {
                            evt = Activator.CreateInstance(eventType, new[] { entry.Entity }) as INotification;
                        }


                        if (evt != null)
                        {
                            events.Add(evt);
                        }
                    }
                }

                foreach (var evt in events)
                {
                    await mediator.Publish(evt);
                }
            }
        }

        private Entry[] GetEntries(BlueprintContext db)
        {
            var entries = db.Entries
                .Where(x => x.State == EntityState.Added ||
                            x.State == EntityState.Modified ||
                            x.State == EntityState.Deleted)
                .ToList();

            db.Entries.Clear();
            return entries.ToArray();
        }
    }
}